from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi import FastAPI

app = FastAPI()

import Schemas
import BaseModels

#--HINT:--engine = create_engine('postgresql+psycopg2://user:password@hostname/database_name')
KnownDatabase = 'postgresql+psycopg2://postgres:example@postgres/postgres'

async def connecttoDatabase(KnownDatabase):
	engine = create_engine(KnownDatabase)
	Session = sessionmaker(bind=engine)
	session = Session()
	return session

def get_db():
	db = Session()
	try:
		yield db
	finally:
		db.close()

def connectAllEndpoints(app):

	@app.post("/users/{name_ed}", response_model=usersGetSchema)
	async def createusers(name_ed: str,users:usersCreateSchema,db: Session=Depends(get_db)):
		usersRow_name = db.query(publicusers).filter(publicusers.name == name_ed).first()
		if usersRow_name:
			raise HTTPException(status_code=400, detail="Error: This name already exist!")
		usersCreateRow_name = publicusers( name = name_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(usersCreateRow_name)
		db.commit()
		db.refresh(usersCreateRow_name)
		result = await (usersCreateRow_name)
		return result

	@app.get("/users", response_model=usersGetSchema)
	async def getusers(users: Schemas.usersGetSchema, db: Session=Depends(get_db))):
		return(db.query(publicusers).first())
	async def getAllusers(db: Depends(connecttoDatabase(KnownDatabase)), skip: int = 0, limit: int = 100):
		return(db.query(publicusers).offset(skip).limit(limit).all())

	@app.put("/users", response_model=usersGetSchema)
	async def updateusers(users: Schemas.usersUpdateSchema, db: Session=Depends(get_db))):
		usersToUpdate = db.query(publicusers).first()
		db.commit()
		db.refresh(usersToUpdate)
		return(usersToUpdate)

	@app.delete("/users", response_model=usersGetSchema)
	async def deleteusers(users: Schemas.usersDeleteSchema, db: Session=Depends(get_db))):
		users_to_delete = db.query(publicusers).filter(publicusers == users).first()
		db.delete(users_to_delete)
		db.comit()
		db.refresh(users_to_delete)
		return(users_to_delete)

	@app.post("/usergroups/{user_id_ed}", response_model=usergroupsGetSchema)
	async def createusergroups(user_id_ed: int,usergroups:usergroupsCreateSchema,db: Session=Depends(get_db)):
		usergroupsRow_user_id = db.query(publicusergroups).filter(publicusergroups.user_id == user_id_ed).first()
		if usergroupsRow_user_id:
			raise HTTPException(status_code=400, detail="Error: This user_id already exist!")
		usergroupsCreateRow_user_id = publicusergroups( user_id = user_id_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(usergroupsCreateRow_user_id)
		db.commit()
		db.refresh(usergroupsCreateRow_user_id)
		result = await (usergroupsCreateRow_user_id)
		return result

	@app.post("/usergroups/{group_id_ed}", response_model=usergroupsGetSchema)
	async def createusergroups(group_id_ed: int,usergroups:usergroupsCreateSchema,db: Session=Depends(get_db)):
		usergroupsRow_group_id = db.query(publicusergroups).filter(publicusergroups.group_id == group_id_ed).first()
		if usergroupsRow_group_id:
			raise HTTPException(status_code=400, detail="Error: This group_id already exist!")
		usergroupsCreateRow_group_id = publicusergroups( group_id = group_id_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(usergroupsCreateRow_group_id)
		db.commit()
		db.refresh(usergroupsCreateRow_group_id)
		result = await (usergroupsCreateRow_group_id)
		return result

	@app.get("/usergroups", response_model=usergroupsGetSchema)
	async def getusergroups(usergroups: Schemas.usergroupsGetSchema, db: Session=Depends(get_db))):
		return(db.query(publicusergroups).first())
	async def getAllusergroups(db: Depends(connecttoDatabase(KnownDatabase)), skip: int = 0, limit: int = 100):
		return(db.query(publicusergroups).offset(skip).limit(limit).all())

	@app.put("/usergroups", response_model=usergroupsGetSchema)
	async def updateusergroups(usergroups: Schemas.usergroupsUpdateSchema, db: Session=Depends(get_db))):
		usergroupsToUpdate = db.query(publicusergroups).first()
		db.commit()
		db.refresh(usergroupsToUpdate)
		return(usergroupsToUpdate)

	@app.delete("/usergroups", response_model=usergroupsGetSchema)
	async def deleteusergroups(usergroups: Schemas.usergroupsDeleteSchema, db: Session=Depends(get_db))):
		usergroups_to_delete = db.query(publicusergroups).filter(publicusergroups == usergroups).first()
		db.delete(usergroups_to_delete)
		db.comit()
		db.refresh(usergroups_to_delete)
		return(usergroups_to_delete)

	@app.post("/groups/{name_ed}", response_model=groupsGetSchema)
	async def creategroups(name_ed: str,groups:groupsCreateSchema,db: Session=Depends(get_db)):
		groupsRow_name = db.query(publicgroups).filter(publicgroups.name == name_ed).first()
		if groupsRow_name:
			raise HTTPException(status_code=400, detail="Error: This name already exist!")
		groupsCreateRow_name = publicgroups( name = name_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(groupsCreateRow_name)
		db.commit()
		db.refresh(groupsCreateRow_name)
		result = await (groupsCreateRow_name)
		return result

	@app.get("/groups", response_model=groupsGetSchema)
	async def getgroups(groups: Schemas.groupsGetSchema, db: Session=Depends(get_db))):
		return(db.query(publicgroups).first())
	async def getAllgroups(db: Depends(connecttoDatabase(KnownDatabase)), skip: int = 0, limit: int = 100):
		return(db.query(publicgroups).offset(skip).limit(limit).all())

	@app.put("/groups", response_model=groupsGetSchema)
	async def updategroups(groups: Schemas.groupsUpdateSchema, db: Session=Depends(get_db))):
		groupsToUpdate = db.query(publicgroups).first()
		db.commit()
		db.refresh(groupsToUpdate)
		return(groupsToUpdate)

	@app.delete("/groups", response_model=groupsGetSchema)
	async def deletegroups(groups: Schemas.groupsDeleteSchema, db: Session=Depends(get_db))):
		groups_to_delete = db.query(publicgroups).filter(publicgroups == groups).first()
		db.delete(groups_to_delete)
		db.comit()
		db.refresh(groups_to_delete)
		return(groups_to_delete)

	@app.post("/uzivatel/{jmeno_ed}", response_model=uzivatelGetSchema)
	async def createuzivatel(jmeno_ed: str,uzivatel:uzivatelCreateSchema,db: Session=Depends(get_db)):
		uzivatelRow_jmeno = db.query(publicuzivatel).filter(publicuzivatel.jmeno == jmeno_ed).first()
		if uzivatelRow_jmeno:
			raise HTTPException(status_code=400, detail="Error: This jmeno already exist!")
		uzivatelCreateRow_jmeno = publicuzivatel( jmeno = jmeno_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(uzivatelCreateRow_jmeno)
		db.commit()
		db.refresh(uzivatelCreateRow_jmeno)
		result = await (uzivatelCreateRow_jmeno)
		return result

	@app.post("/uzivatel/{prijmeni_ed}", response_model=uzivatelGetSchema)
	async def createuzivatel(prijmeni_ed: str,uzivatel:uzivatelCreateSchema,db: Session=Depends(get_db)):
		uzivatelRow_prijmeni = db.query(publicuzivatel).filter(publicuzivatel.prijmeni == prijmeni_ed).first()
		if uzivatelRow_prijmeni:
			raise HTTPException(status_code=400, detail="Error: This prijmeni already exist!")
		uzivatelCreateRow_prijmeni = publicuzivatel( prijmeni = prijmeni_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(uzivatelCreateRow_prijmeni)
		db.commit()
		db.refresh(uzivatelCreateRow_prijmeni)
		result = await (uzivatelCreateRow_prijmeni)
		return result

	@app.post("/uzivatel/{datum_narozeni_ed}", response_model=uzivatelGetSchema)
	async def createuzivatel(datum_narozeni_ed: int,uzivatel:uzivatelCreateSchema,db: Session=Depends(get_db)):
		uzivatelRow_datum_narozeni = db.query(publicuzivatel).filter(publicuzivatel.datum_narozeni == datum_narozeni_ed).first()
		if uzivatelRow_datum_narozeni:
			raise HTTPException(status_code=400, detail="Error: This datum_narozeni already exist!")
		uzivatelCreateRow_datum_narozeni = publicuzivatel( datum_narozeni = datum_narozeni_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(uzivatelCreateRow_datum_narozeni)
		db.commit()
		db.refresh(uzivatelCreateRow_datum_narozeni)
		result = await (uzivatelCreateRow_datum_narozeni)
		return result

	@app.post("/uzivatel/{pocet_clanku_ed}", response_model=uzivatelGetSchema)
	async def createuzivatel(pocet_clanku_ed: int,uzivatel:uzivatelCreateSchema,db: Session=Depends(get_db)):
		uzivatelRow_pocet_clanku = db.query(publicuzivatel).filter(publicuzivatel.pocet_clanku == pocet_clanku_ed).first()
		if uzivatelRow_pocet_clanku:
			raise HTTPException(status_code=400, detail="Error: This pocet_clanku already exist!")
		uzivatelCreateRow_pocet_clanku = publicuzivatel( pocet_clanku = pocet_clanku_ed *staci?? nebo je treba vse z modelu ?? )
		db.add(uzivatelCreateRow_pocet_clanku)
		db.commit()
		db.refresh(uzivatelCreateRow_pocet_clanku)
		result = await (uzivatelCreateRow_pocet_clanku)
		return result

	@app.get("/uzivatel", response_model=uzivatelGetSchema)
	async def getuzivatel(uzivatel: Schemas.uzivatelGetSchema, db: Session=Depends(get_db))):
		return(db.query(publicuzivatel).first())
	async def getAlluzivatel(db: Depends(connecttoDatabase(KnownDatabase)), skip: int = 0, limit: int = 100):
		return(db.query(publicuzivatel).offset(skip).limit(limit).all())

	@app.put("/uzivatel", response_model=uzivatelGetSchema)
	async def updateuzivatel(uzivatel: Schemas.uzivatelUpdateSchema, db: Session=Depends(get_db))):
		uzivatelToUpdate = db.query(publicuzivatel).first()
		db.commit()
		db.refresh(uzivatelToUpdate)
		return(uzivatelToUpdate)

	@app.delete("/uzivatel", response_model=uzivatelGetSchema)
	async def deleteuzivatel(uzivatel: Schemas.uzivatelDeleteSchema, db: Session=Depends(get_db))):
		uzivatel_to_delete = db.query(publicuzivatel).filter(publicuzivatel == uzivatel).first()
		db.delete(uzivatel_to_delete)
		db.comit()
		db.refresh(uzivatel_to_delete)
		return(uzivatel_to_delete)
